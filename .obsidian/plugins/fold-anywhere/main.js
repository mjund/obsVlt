/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/foldAnyWhereIndex.ts
var foldAnyWhereIndex_exports = {};
__export(foldAnyWhereIndex_exports, {
  FoldAnywhereSettingTab: () => FoldAnywhereSettingTab,
  default: () => FoldAnyWherePlugin
});
module.exports = __toCommonJS(foldAnyWhereIndex_exports);
var import_obsidian3 = require("obsidian");

// src/widgets/foldService.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_obsidian = require("obsidian");
function createFoldRangesFromCurrentPOS(settings, state, currentPos) {
  const startRegex = new RegExp(settings.startMarker, "g");
  const endRegex = new RegExp(settings.endMarker, "g");
  let ranges = [];
  let startStack = [];
  let currentLine = state.doc.lineAt(currentPos);
  for (let i = currentLine.number; i <= state.doc.lines; i++) {
    const line = state.doc.line(i);
    startRegex.lastIndex = 0;
    endRegex.lastIndex = 0;
    let tempStartPositions = [];
    let match;
    while ((match = startRegex.exec(line.text)) !== null) {
      tempStartPositions.push(line.from + match.index);
    }
    if (tempStartPositions.length > 1) {
      tempStartPositions.forEach((pos) => startStack.push(pos));
    } else if (tempStartPositions.length === 1) {
      startStack.push(tempStartPositions[0]);
    }
    let endMatch;
    while ((endMatch = endRegex.exec(line.text)) !== null) {
      let endPosition = line.from + endMatch.index + endMatch[0].length;
      if (startStack.length) {
        let start = startStack.pop();
        if (start !== void 0 && start < currentPos) {
          ranges.push({ from: start, to: endPosition });
        }
      } else {
        for (let j = i - 1; j >= 1; j--) {
          const searchLine = state.doc.line(j);
          startRegex.lastIndex = 0;
          if (endRegex.test(searchLine.text)) {
            break;
          }
          let startMatch;
          if ((startMatch = startRegex.exec(searchLine.text)) !== null) {
            ranges.push({ from: searchLine.from + startMatch.index, to: endPosition });
            break;
          }
        }
      }
      if (ranges.length > 0 && startStack.length === 0) {
        break;
      }
    }
  }
  const validRanges = ranges.filter((range) => range.from < currentPos && range.to > currentPos);
  validRanges.sort((a, b) => a.to - a.from - (b.to - b.from));
  return validRanges.length > 0 ? validRanges.slice(0, 1) : [];
}
function findMatchingFoldRange(state, currentPos) {
  const settings = state.field(import_obsidian.editorInfoField).app.plugins.getPlugin("fold-anywhere").settings;
  const startRegex = new RegExp(settings.startMarker, "g");
  const endRegex = new RegExp(settings.endMarker, "g");
  let startStack = [];
  let currentLine = state.doc.lineAt(currentPos);
  for (let i = currentLine.number; i <= state.doc.lines; i++) {
    const line = state.doc.line(i);
    startRegex.lastIndex = 0;
    endRegex.lastIndex = 0;
    let match;
    while ((match = startRegex.exec(line.text)) !== null) {
      startStack.push(line.from + match.index);
    }
    if (i === currentLine.number && startStack.length === 0) {
      return null;
    }
    let endMatch;
    while ((endMatch = endRegex.exec(line.text)) !== null && startStack.length) {
      let start = startStack.pop();
      let endPosition = line.from + endMatch.index + endMatch[0].length;
      if (startStack.length === 0) {
        return { from: start, to: endPosition };
      }
    }
  }
  return null;
}
function getAllFoldableRanges(state) {
  const settings = state.field(import_obsidian.editorInfoField).app.plugins.getPlugin("fold-anywhere").settings;
  const startRegex = new RegExp(settings.startMarker, "g");
  const endRegex = new RegExp(settings.endMarker, "g");
  let ranges = [];
  let startStack = [];
  for (let i = 1; i <= state.doc.lines; i++) {
    const line = state.doc.line(i);
    startRegex.lastIndex = 0;
    endRegex.lastIndex = 0;
    let match;
    while ((match = startRegex.exec(line.text)) !== null) {
      startStack.push(line.from + match.index);
    }
    if (endRegex.test(line.text) && startStack.length) {
      let start = startStack.pop();
      if (start !== void 0) {
        ranges.push({ from: start, to: line.to });
      }
    }
  }
  return ranges;
}
function foldServiceFunc(state, lineStart, lineEnd) {
  let range = findMatchingFoldRange(state, lineStart);
  if (!range)
    return null;
  return range;
}
var foldRanges = import_state.StateField.define({
  create: (state) => getAllFoldableRanges(state),
  update(value, tr) {
    return value;
  }
});
var FoldingExtension = [
  (0, import_language.codeFolding)({
    placeholderDOM(view, onclick) {
      const placeholder = createEl("span", {
        text: "...",
        cls: "cm-foldPlaceholder"
      });
      placeholder.onclick = onclick;
      return placeholder;
    }
  }),
  foldRanges,
  import_language.foldService.of(foldServiceFunc)
];
function foldAll(view) {
  var _a, _b;
  const settings = view.state.field(import_obsidian.editorInfoField).app.plugins.getPlugin("fold-anywhere").settings;
  const ranges = createFoldRangesFromCurrentPOS(settings, view.state, view.state.selection.main.head);
  if (ranges.length > 0) {
    const effects = ranges.map((range) => import_language.foldEffect.of(range));
    view.dispatch({ effects });
    view.dispatch({
      selection: { anchor: ((_a = ranges.last()) == null ? void 0 : _a.to) || 0, head: ((_b = ranges.last()) == null ? void 0 : _b.to) || 0 }
    });
  }
}
function unfoldAll(view) {
  const settings = view.state.field(import_obsidian.editorInfoField).app.plugins.getPlugin("fold-anywhere").settings;
  const ranges = createFoldRangesFromCurrentPOS(settings, view.state, view.state.selection.main.head);
  if (ranges.length > 0) {
    const effects = ranges.map((range) => import_language.unfoldEffect.of(range));
    view.dispatch({ effects });
  }
}
var foldService_default = FoldingExtension;

// src/widgets/foldMarkerWidget.ts
var import_view = require("@codemirror/view");
var import_obsidian2 = require("obsidian");
var FoldMarkWidget = class extends import_view.WidgetType {
  constructor(app, view, from, to, markType = "fold", isFolded = false) {
    super();
    this.app = app;
    this.view = view;
    this.from = from;
    this.to = to;
    this.markType = markType;
    this.isFolded = isFolded;
  }
  eq(other) {
    return other.view === this.view && other.from === this.from && other.to === this.to;
  }
  toDOM() {
    const creaseEl = createSpan("cm-fold-anywhere-icon");
    const iconEl = creaseEl.createSpan(this.markType === "fold" ? "fold-start" : "fold-end");
    let title, icon;
    if (this.markType === "fold") {
      title = "Remove fold start mark";
      icon = this.isFolded ? "goal" : "chevron-last";
    } else {
      title = "Remove fold end mark";
      icon = "chevron-first";
    }
    (0, import_obsidian2.setIcon)(iconEl, icon);
    creaseEl.addEventListener("click", (evt) => {
      if (evt.ctrlKey || evt.metaKey) {
        const menu = new import_obsidian2.Menu();
        menu.addItem((item) => item.setTitle(title).setIcon("x").onClick(() => {
          this.view.dispatch({
            changes: {
              from: this.from,
              to: this.to,
              insert: ""
            }
          });
        })).showAtMouseEvent(evt);
        return;
      }
      this.view.dispatch({
        selection: {
          anchor: (this.markType === "fold" ? this.to : this.from) || 0,
          head: (this.markType === "fold" ? this.to : this.from) || 0
        }
      });
      foldAll(this.view);
    });
    return creaseEl;
  }
  ignoreEvent(event) {
    return false;
  }
};
function foldAllPlugin(app, plugin) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = import_view.Decoration.none;
      this.allDecos = import_view.Decoration.none;
      const regex = new RegExp(`((?<START>${plugin.settings.startMarker})|(?<END>${plugin.settings.endMarker}))`, "g");
      this.decorator = new import_view.MatchDecorator({
        regexp: regex,
        decoration: this.getDeco.bind(this)
      });
      this.decorations = this.decorator.createDeco(view);
    }
    getDeco(match, _view, pos) {
      var _a, _b;
      const from = pos;
      const to = pos + match[0].length;
      console.log(from, to, ((_a = match.groups) == null ? void 0 : _a.START) ? "fold" : "unfold");
      return import_view.Decoration.replace({
        widget: new FoldMarkWidget(app, this.view, from, to, ((_b = match.groups) == null ? void 0 : _b.START) ? "fold" : "unfold")
      });
    }
    update(update) {
      if (!update.state.field(import_obsidian2.editorLivePreviewField)) {
        this.decorations = import_view.Decoration.none;
        return;
      }
      this.decorations = this.decorator.updateDeco(update, this.decorations);
    }
  }, {
    decorations: (v) => v.decorations,
    provide: (plugin2) => import_view.EditorView.atomicRanges.of((view) => {
      var _a;
      return ((_a = view.plugin(plugin2)) == null ? void 0 : _a.decorations) || import_view.Decoration.none;
    })
  });
}

// src/utils/line.ts
var BLOCK_ID_REGEX = /\^[a-zA-Z0-9\-]{1,6}$/g;
var checkStartOrEnd = (editor) => {
  const fromCursor = editor.getCursor("from");
  const toCursor = editor.getCursor("to");
  const lineStart = fromCursor.ch === 0 || editor.getLine(fromCursor.line).charAt(fromCursor.ch - 1) === " ";
  const lineEnd = toCursor.ch === editor.getLine(toCursor.line).length || editor.getLine(toCursor.line).charAt(toCursor.ch) === " ";
  return { lineStart, lineEnd, toCursor };
};
var insertEndMarkBeforeBlockID = (content, end) => {
  const match = content.match(BLOCK_ID_REGEX);
  if (match) {
    return content.replace(BLOCK_ID_REGEX, `${end} ${match[0]}`);
  } else {
    return content + ` ${end}`;
  }
};
var dealWithSelection = (insert, editor) => {
  const selection = editor.getSelection();
  if (selection.trim().length === 0)
    return;
  const { lineStart, lineEnd, toCursor } = checkStartOrEnd(editor);
  editor.replaceSelection((lineStart ? `` : ` `) + `${insert.startMarker} ${insertEndMarkBeforeBlockID(selection.trim(), insert.endMarker)}` + (lineEnd ? `` : ` `));
  editor.setCursor(toCursor.line, toCursor.ch + 14);
  foldAll(editor.cm);
};
var insertMark = (insert, editor, type) => {
  const selection = editor.getSelection();
  if (selection.trim().length > 0)
    return;
  const { lineStart, lineEnd } = checkStartOrEnd(editor);
  editor.replaceSelection((lineStart ? `` : ` `) + (type === "start" ? insert.startMarker : insert.endMarker) + (lineEnd ? type === "start" ? ` ` : `` : ` `));
};

// src/foldAnyWhereIndex.ts
var DEFAULT_SETTINGS = {
  startMarker: "%% REGION %%",
  endMarker: "%% ENDREGION %%"
};
var FoldAnyWherePlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new FoldAnywhereSettingTab(this.app, this));
    this.registerIcons();
    this.registerCommands();
    this.registerContextMenu();
    this.registerEditorExtension([foldService_default, foldAllPlugin(this.app, this)]);
  }
  onunload() {
  }
  registerIcons() {
    (0, import_obsidian3.addIcon)("fold-horizontal", `<g xmlns="http://www.w3.org/2000/svg" id="surface1"><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 1.999687 12 L 7.999687 12 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 22.000312 12 L 16.000312 12 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 1.999687 L 12 4.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 7.999687 L 12 10.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 13.999688 L 12 16.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 19.999688 L 12 22.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 19.000312 9 L 16.000312 12 L 19.000312 15 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 4.999687 15 L 7.999687 12 L 4.999687 9 " transform="matrix(4.166667,0,0,4.166667,0,0)"/></g>`);
  }
  registerCommands() {
    this.addCommand({
      id: "fold-current-range",
      name: "Fold between start and end marks",
      editorCallback: (editor) => {
        const editorView = editor.cm;
        foldAll(editorView);
      }
    });
    this.addCommand({
      id: "unfold-current-range",
      name: "Unfold between start and end marks",
      editorCallback: (editor) => {
        const editorView = editor.cm;
        unfoldAll(editorView);
      }
    });
    this.addCommand({
      id: "fold-selected-text",
      name: "Fold selected text",
      editorCallback: (editor) => dealWithSelection(this.settings, editor)
    });
    this.addCommand({
      id: "mark-as-start",
      name: "Mark as start",
      editorCallback: (editor) => insertMark(this.settings, editor, "start")
    });
    this.addCommand({
      id: "mark-as-end",
      name: "Mark as end",
      editorCallback: (editor) => insertMark(this.settings, editor, "end")
    });
    this.addCommand({
      id: "remove-all-markers",
      name: "Remove All Markers In Current File",
      callback: async () => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (markdownView) {
          const file = markdownView.file;
          if (!file)
            return;
          let ready = false;
          new AskModal(this.app, async (already) => {
            ready = already;
            if (ready) {
              const fileContent = await this.app.vault.cachedRead(file);
              const startMarker = this.settings.startMarker;
              const endMarker = this.settings.endMarker;
              const regex = new RegExp(`(\\s)?${startMarker}|(\\s)?${endMarker}`, "g");
              const newFileContent = fileContent.replace(regex, "");
              await this.app.vault.modify(file, newFileContent);
            }
          }).open();
          return;
        }
        new import_obsidian3.Notice("No active file open");
      }
    });
  }
  registerContextMenu() {
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor) => {
      if (!editor) {
        return;
      }
      const selection = editor.getSelection();
      menu.addItem((item) => {
        const subMenu = item.setSection("action").setTitle(`Fold anywhere`).setIcon("chevrons-right-left").setSubmenu();
        subMenu.addItem((item2) => {
          item2.setIcon("fold-horizontal").setTitle("Fold selected text").setDisabled(!selection.trim()).onClick(() => dealWithSelection(this.settings, editor));
        });
        subMenu.addItem((item2) => {
          item2.setIcon("chevron-last").setTitle("Mark as start").setDisabled(!!selection.trim()).onClick(() => insertMark(this.settings, editor, "start"));
        });
        subMenu.addItem((item2) => {
          item2.setIcon("chevron-first").setTitle("Mark as end").setDisabled(!!selection.trim()).onClick(() => insertMark(this.settings, editor, "end"));
        });
      });
    }));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AskModal = class extends import_obsidian3.Modal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.toggleClass("fold-anywhere-ask-modal", true);
    contentEl.createEl("div", { text: "Are you sure?" });
    const buttonContainer = contentEl.createDiv({ cls: "button-container" });
    new import_obsidian3.ButtonComponent(buttonContainer).setClass("remove-ready").setWarning().setButtonText("Yes").onClick(async () => {
      await this.cb(true);
      this.close();
    });
    new import_obsidian3.ButtonComponent(buttonContainer).setClass("do-not-remove").setButtonText("No").onClick(async () => {
      await this.cb(false);
      this.close();
    });
  }
};
var FoldAnywhereSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.debounceApplySettingsUpdate = (0, import_obsidian3.debounce)(async () => {
      await this.plugin.saveSettings();
    }, 200, true);
    this.debounceDisplay = (0, import_obsidian3.debounce)(async () => {
      await this.display();
    }, 400, true);
    this.plugin = plugin;
  }
  applySettingsUpdate() {
    this.debounceApplySettingsUpdate();
  }
  async display() {
    await this.plugin.loadSettings();
    const { containerEl } = this;
    const settings = this.plugin.settings;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Fold anywhere start marker").addText((text) => text.setValue(settings.startMarker).onChange(async (value) => {
      settings.startMarker = value;
      this.applySettingsUpdate();
    }));
    new import_obsidian3.Setting(containerEl).setName("Fold anywhere end marker").addText((text) => text.setValue(settings.endMarker).onChange(async (value) => {
      settings.endMarker = value;
      this.applySettingsUpdate();
    }));
  }
};
